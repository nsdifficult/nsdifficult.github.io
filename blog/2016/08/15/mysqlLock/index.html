
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>InnoDB锁学习笔记 - RONGYI.WORK</title>
	<meta name="author" content="易荣义">

	
	<meta name="description" content="Shared and Exclusive Locks 即s锁/共享锁/读锁 和 x锁/排他锁/写锁。 s锁只允许别的事务在其持有数据上加s锁。顾名思义，x锁会让其他请求其数据的事务等待。 Intention Locks Intention &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="RONGYI.WORK" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="http://libs.useso.com/js/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">RONGYI.WORK</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">主页</a></li>
	<li><a href="/blog/archives">所有文章</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">主页</a></li>
	<li><a href="/blog/archives">所有文章</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:rongyi.work">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:rongyi.work">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">InnoDB锁学习笔记</h2>
	<div class="entry-content"><h3>Shared and Exclusive Locks</h3>

<p>即s锁/共享锁/读锁 和 x锁/排他锁/写锁。 <br/>
s锁只允许别的事务在其持有数据上加s锁。顾名思义，x锁会让其他请求其数据的事务等待。<!--more--></p>

<h3>Intention Locks</h3>

<p>Intention Locks的目的是InnoDB为支持不同粒度的锁而引入的一种锁，它是表级锁。简单点儿说就是在一个事务要确定对哪些范围的数据加锁前，先使用Intention Locks。同样，它也分： Intention shared (IS)锁和Intention exclusive (IX)锁。 <br/>
这些规则可以总结为以下的锁兼容矩阵：</p>

<table>
<thead>
<tr>
<th>   </th>
<th style="text-align:center;"> X </th>
<th> IX    </th>
<th> S  </th>
<th style="text-align:center;"> IS </th>
</tr>
</thead>
<tbody>
<tr>
<td> X  </td>
<td style="text-align:center;"> Confict </td>
<td> Confict     </td>
<td> Confict </td>
<td style="text-align:center;"> Confict </td>
</tr>
<tr>
<td> IX </td>
<td style="text-align:center;"> Confict  </td>
<td> Compatible      </td>
<td>  Confict  </td>
<td style="text-align:center;"> Confict </td>
</tr>
<tr>
<td> S  </td>
<td style="text-align:center;"> Confict  </td>
<td> Confict </td>
<td> Compatible     </td>
<td style="text-align:center;"> Confict </td>
</tr>
<tr>
<td> IS  </td>
<td style="text-align:center;"> Confict   </td>
<td> Compatible </td>
<td> Compatible     </td>
<td style="text-align:center;"> Confict </td>
</tr>
</tbody>
</table>


<p>如果一个事务请求的锁和已经存在的锁兼容，则此事务会得到锁，否则不能得到锁。事务会等待直到已有的冲突锁被释放。如果一个锁请求和已有的锁发生冲突，则它不会得到锁，因为会发生死锁并引发错误。</p>

<h3>Record Locks</h3>

<p>Record Locks是加在特定记录上的锁，该记录对应列为索引列。例如，SELECT c1 FOR UPDATE FROM t WHERE c1 = 10;可以防止任何其它事务插入、 更新或删除t.c1等于10的行。</p>

<h3>Gap Locks</h3>

<p>Gap Locks是加在一个索引范围内记录上的锁，或者索引开始记录前，索引结束记录后的这一范围的锁。即Gap Locks锁定一个范围，不锁定记录本身。Gap Locks主要为了解决幻读问题（隔离级别为Reapted Read）。 <br/>
在InnoDB中，间隙锁是“完全被抑制”的，意思是它只阻止其它事务给往间隙中插入。它们不阻止其他事务在同一个间隙上获得间隙锁。因此，一个间隙X锁和一个间隙S锁效果一样。  <br/>
可以显式禁用间隙锁。如果你更改事务隔离级别为READ COMMITTED或启用innodb_locks_unsafe_for_binlog系统变量 （现已废弃），禁用会生效。在这些情况下，间隙锁在查找和索引扫描时会被禁用，仅在外键约束检查和重复键检查时启用。</p>

<h3>Next-Key Locks</h3>

<p>Record Locks和Gap Locks的结合，锁定一个范围的记录。即锁定范围且锁定记录本身。</p>

<h3>Insert Intention Locks</h3>

<p>一个Insert Intention Locks是插入操作在插入某行或者某些行记录前放置的一种Gap Lock锁。它的存在是为了保证不同的事务如果要往不同的Gap里插入记录，而不互相影响。</p>

<h3>AUTO-INC Locks</h3>

<p>AUTO-INC Locks是一种表锁，当往自增列插入时会使用AUTO-INC Locks。  <br/>
innodb_autoinc_lock_mode配置可以调整该锁。</p>

<ul>
<li><p><code>innodb_autoinc_lock_mode=0</code>通过表锁的方式进行，也就是所有类型的insert都用AUTO-inc locking。</p></li>
<li><p><code>innodb_autoinc_lock_mode=1</code>默认值，对于simple insert 自增长值的产生使用互斥量对内存中的计数器进行累加操作，对于bulk insert 则还是使用表锁的方式进行。</p></li>
<li><p><code>innodb_autoinc_lock_mode=2</code>对所有的insert-like 自增长值的产生使用互斥量机制完成，性能最高，并发插入可能导致自增值不连续，可能会导致Statement 的 Replication 出现不一致，使用该模式，需要用 Row Replication的模式。</p></li>
</ul>


<h3>Predicate Locks for Spatial Indexes</h3>

<p>空间索引预测锁，暂时用不到。忽略。</p>

<h2>MySql锁</h2>

<h3>锁超时设置与查看</h3>

<p>参数支持范围为Session和Global，且支持动态修改，所以可以通过两种方法修改；  <br/>
查看：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">show</span> <span class="n">variables</span> <span class="n">like</span> <span class="err">&#39;</span><span class="n">innodb_lock_wait_timeout</span><span class="err">&#39;</span><span class="o">;</span> <span class="o">--</span> <span class="n">查看</span>
</span></code></pre></td></tr></table></div></figure>


<p>修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">set</span>  <span class="n">innodb_lock_wait_timeout</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>   <span class="o">--</span> <span class="n">设置</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者修改my.cnf文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="n">innodb_lock_wait_timeout</span> <span class="o">=</span> <span class="mi">50</span>
</span></code></pre></td></tr></table></div></figure>


<p>更详细了解可以看看这篇文章<a href="http://www.importnew.com/2466.html">深入理解JDBC的超时设置</a></p>

<h3>未提交事务查看</h3>

<p>information_schema库下事务和锁的一些描述： <br/>
* innodb_trx  当前运行的所有事务
* innodb_locks  当前出现的锁
* innodb_lock_waits  锁等待的对应关系</p>

<h2>如何查看SQL语句使用什么锁</h2>

<h3>InnoDB行锁</h3>

<p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！  <br/>
1. 在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。  <br/>
2. 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。 <br/>
3. 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。  <br/>
4. 即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p>

<h3>举例说明</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">person</span> <span class="p">(</span>
</span><span class='line'>        <span class="n">id</span> <span class="nb">int</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
</span><span class='line'>        <span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
</span><span class='line'>        <span class="n">age</span> <span class="nb">int</span><span class="p">,</span>
</span><span class='line'>        <span class="n">address</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
</span><span class='line'>        <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
</span><span class='line'>        <span class="k">CONSTRAINT</span> <span class="n">nameIdx</span> <span class="k">UNIQUE</span> <span class="p">(</span><span class="n">name</span><span class="p">),</span>
</span><span class='line'>        <span class="k">INDEX</span> <span class="n">ageIdx</span> <span class="p">(</span><span class="n">age</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
</span><span class='line'><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">person</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;900&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;BeiJing&#39;</span><span class="p">);</span>
</span><span class='line'><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">person</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;800&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;ShangHai&#39;</span><span class="p">);</span>
</span><span class='line'><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">person</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;930&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;NanJing&#39;</span><span class="p">);</span>
</span><span class='line'><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">person</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="s1">&#39;950&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;NanJing&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>仅分析事务隔离级别为Reapted Read级别情况下的加锁情况。</p>

<h4>执行如下sql：</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">delete</span> <span class="k">from</span> <span class="n">person</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="s1">&#39;5&#39;</span><span class="p">;</span><span class="o">//</span><span class="mi">1</span>
</span><span class='line'><span class="k">delete</span> <span class="k">from</span> <span class="n">person</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;900&#39;</span><span class="p">;</span><span class="o">//</span><span class="mi">2</span>
</span><span class='line'><span class="k">delete</span> <span class="k">from</span> <span class="n">person</span> <span class="k">where</span> <span class="n">age</span> <span class="o">=</span> <span class="s1">&#39;20&#39;</span><span class="p">;</span><span class="o">//</span><span class="mi">3</span>
</span><span class='line'><span class="k">delete</span> <span class="k">from</span> <span class="n">person</span> <span class="k">where</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;NanJing&#39;</span><span class="p">;</span><span class="o">//</span><span class="mi">4</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Record Lock
 主键id对应为5的记录加Record Lock</li>
<li>Record Lock
 索引nameIdx为900对应的记录加Record Lock，同时满足主键为3的记录也被加Record Lock</li>
<li>Record Lock 和 Gap Lock
 ageIdx为20的记录加Record Lock，同时满足(5,20],(20,+∞)的Gap被加Gap Lock(解决幻读)。</li>
<li>Record Lock 和 Gap Lock
 所有记录都加了Record Lock 和 所有主键索引间的Gap都加了Gap Lock（解决幻读）</li>
</ol>


<p>关于具体sql分析，可以参考这篇文章: <a href="http://hedengcheng.com/?p=771">MySQL 加锁处理分析</a></p>
</div>


<div class="meta">
	<div class="date">




Aug 15th, 2016</div>
	<div class="tags">

</div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		
		
	</div>
	
</div>




  <section>
    <h1>评论</h1>
    <div id="comments" aria-live="polite"><!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="/blog/2016/08/15/mysqlLock" data-title="InnoDB锁学习笔记" data-url="http://rongyi.work/blog/2016/08/15/mysqlLock/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    var duoshuoQuery = {short_name:"24yi"};
    (function() {

        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
     })();
 </script>
 <!-- 多说公共JS代码 end -->
</div>
  </section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    易荣义

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>