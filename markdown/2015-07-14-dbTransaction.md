---
layout: post
title: "再谈数据库事务"
date: 2015-07-14 09:06
comments: true
categories: 
---

# 再谈数据库事务

## 放在前面要说的
本文文字完全总结（95%）自《Spring3.x企业应用开发实战》，《高性能MySQL》。写在这里是为了方便自己查阅。<!--more-->
## 定义
>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的一个逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。

### ACID说明
* 原子性(Atomic)：表示组成一个事务的多个数据操作是一个不可分割的原子单元，只有所有的操作执行成功，整个事务才提交，事务中任何一个数据库操作失败，已经执行的任何操作都必须撤销，让数据库返回到初始状态。
* 一致性(Consistency)：数据库总是从一个一致性的状态转换到另外一个一致性的状态。事务操作成功后，数据库所处的状态和它的业务规则是一致的，即数据不会被破坏。如从A账户转账100元到B账户，不管操作成功与否，A和B的存款总额是不变的。
* 隔离性(Isolation)：在并发操作时，不同的事务拥有各自的数据空间，它们的操作不会对对方产生干扰。准确的说，并非要求做到完全干扰，数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性越好，但并发性越弱。
* 持久性(Durabiliy)：一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须保证能够通过某种机制恢复数据。
1. 在这些事务特性中，数据“一致性”是最终目标，其他的特性都是为达到这个目标的措施、要求或手段。   
数据库管理系统一般采用重新执行日志保证**原子性**、**一致性**和**持久性**。     
2. 和Java程序采用对象锁机制进行线程同步类似，数据库管理系统采用数据库锁机制保证事务的**隔离性**。当多个事务试图对相同的数据进行操作时，只有持有锁的事务才能操作数据，直到前一个事务完成后，后面的事务才有机会对数据进行操作。      

## 数据并发的问题
可能会有多个客户端同时访问数据库，多个事务可能同时访问相同的数据，如果没有采取必要的隔离措施，就会导致各种并发问题，破坏数据的完整性。这些问题可以归为5类，包括3类数据读问题（**脏读**、**不可重复读**、**幻象读**）以及2类数据更新问题（**第一类丢失更新**和**第二类丢失更新**）。   

### 脏读(dirty read)
A事务读取B事务尚未提交的更改数据，并在这个数据的基础上操作。如果恰巧B事务回滚，那么A事务读到的数据根本是不被承认的。来看取款事务和转账事务并发时引发的脏读场景：   
![dirtyread.png](/images/transaction/dirtyread.png) 

### 不可重复读
不可重复读是指A事务读取了B事务已经提交的更改数据（**更改**和**删除**）和在B事务未完成时读的数据不一致。假设A在取款事务的过程中，B往该账户转账100元，A两次读取账户的余额发生不一致：   
![nonrepeatRead.png](/images/transaction/nonrepeatRead.png) 

### 幻象读
A事务读取B事务提交的**新增**数据，这时A事务将出现幻象读的问题。幻象读一般发生在计算统计数据的事务中，举一个例子，假设银行系统在同一个事务中，两次统计存款账户的总金额，在两次统计过程中，刚好新增了一个存款账户，并存入100元，这时，两次统计的总金额将不一致：   
![phantomRead.png](/images/transaction/phantomRead.png) 

如果新增数据刚好满足事务的查询条件,这个新数据就进入了事务的视野，因而产生了两个统计不一致的情况。     
幻象读和不可重复读是两个容易混淆的概念，前者是指读到了其他已经提交事务的**新增**数据，而后者是指读到了已经提交事务的更改数据（**更改**或**删除**），为了避免这两种情况，采取的对策是不同的，防止读取到更改数据，只需要对操作的数据添加**行级锁**，阻止操作中的数据发生变化，而防止读取到新增数据，则往往需要添加**表级锁**——将整个表锁定，防止新增数据。   
### 第一类丢失更新
A事务撤销时，把已经提交的B事务的更新数据覆盖了。
![1thLostUpdate.png](/images/transaction/1thLostUpdate.png) 

### 第二类丢失更新
A事务覆盖B事务已经提交的数据，造成B事务所做的操作丢失。
![2thLostUpdate.png](/images/transaction/2thLostUpdate.png) 

## 数据库锁机制
前文讲到，数据库管理系统采用数据库锁机制保证事务的**隔离性**。按照锁定的对象不同，一般分为表锁定和行锁定，前者对整个表进行锁定，而后者对表中特定行进行锁定。从并发事务锁定的关系上看，可以分为共享锁定和独占锁定。共享锁定会防止独占锁定，但允许其他的共享锁定。而独占锁定既防止其他的独占锁定，也防止其他的共享锁定。为了更改数据，数据库必须在进行更改的行上施加行独占锁定，INSERT、UPDATE、DELETE和SELECT FOR UPDATE语句都会隐式采用必要的行锁定。
### 隔离级别
尽管数据库为用户提供了锁的DML(data manipulation language即数据操纵语言：SELECT、UPDATE、INSERT、DELETE)操作方式，但直接使用锁管理非常麻烦，因此数据库为用户提供了自动锁机制。只要用户指定会话的事务隔离级别，数据库就会分析事务中的SQL语句，然后自动为事务操作的数据资源加上适合的锁。     
![IsolationLevel.png](/images/transaction/IsolationLevel.png) 

#### READ UNCOMMITTED(未提交读)
在这个级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（dirty read）。这个级别会导致很多问题，从性能上来说，READ UNCOMMITED不会比其他的级别好太多，但缺乏其他级别的很多好处，除非非常必要的理由，在实际应用中一般很少使用。
#### READ COMMITTED(提交读)
大多数DBMS默认的隔离级别是READ COMMITTED（但MySQL不是）。这个事务满足：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别也叫做不可重复读（nonrepeatable read）,因为两次执行同样的查询，可能会得到不一样的结果。   
#### REPEATABLE READ(可重复读)
MySQL默认事务隔离级别。该级别解决了脏读的问题，但不能解决幻读（Phantom Read）的问题。InnoDB和XtraDB存储引擎通过多版本控制（MVCC,Multiversion Concurrency Control）解决了幻读的问题。
#### SERIALIZABLE(可串行化)
最高的隔离级别，通过强制事务串行执行，避免了幻读的问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁。

